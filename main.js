const { Client, LocalAuth, ChatTypes } = require('whatsapp-web.js');
const wwjs = require('whatsapp-web.js');
const emojis = require('./emojis');
const qrcode = require('qrcode-terminal');
const path = require('path');
const fs = require('fs');
const configPath = './config.json';

let DELAIS = 10000;
let savedMessage = null;
wwjs.ChatTypes.GROUP

const client = new Client({
    authStrategy: new LocalAuth({
        dataPath: "./session"
    })
});

client.once('ready', async () => {
    console.log("Le client a d√©marr√© üèé");

    if (fs.existsSync(configPath)) {
        const data = JSON.parse(fs.readFileSync(configPath));
        if (data.DELAIS) DELAIS = data.DELAIS;
        if (data.savedMessageId) {
            // On r√©cup√®re le message sauvegard√© via son ID apr√®s que le client soit pr√™t
            try {
                savedMessage = await client.getMessageById(data.savedMessageId);
            } catch (error) {
                console.error('Erreur lors du chargement du message sauvegard√©:', error.message);
            }
        }
    }
    

    console.log("Les configs sont charg√©s üíæ")

});

client.on('qr', (qr) => {
    qrcode.generate(qr, { small: true });
});

client.on('error', (error) => {
    console.error('Une erreur s\'est produite:', error);
});

client.initialize();

client.on('message_create', async (message) => {



    if (message.fromMe) {
        if (message.body == ".diffusion") {
            try {
                const groupChat = await client.getChatById(message.id.remote);
                
                if (groupChat.isGroup) { // S'assurer que le message vient d'un groupe pour cette commande
                    await message.reply("D√©marrage de la diffusion aux participants de ce groupe. Veuillez patienter...");
                    await sendPrivateMessages(groupChat.participants);
                    await message.reply("Op√©ration de diffusion termin√©e ! ‚úÖ");
                } else {
                    await message.reply("La commande 'diffusion' doit √™tre utilis√©e dans un groupe.");
                }
            } catch (error) {
                console.error('Erreur lors de la diffusion (diffusion):', error.message);
                await message.reply("‚ùå Une erreur est survenue lors de la tentative de diffusion. Assurez-vous d'√™tre dans un groupe et que le bot a les permissions n√©cessaires.");
            }
        }
        if (message.body == ".diffusion2") {

            try {
                const quotedMessage = await message.getQuotedMessage();
                if (!quotedMessage) {
                    await message.reply("La commande 'diffusion2' doit √™tre utilis√©e en r√©pondant √† un message d'un groupe.");
                    return;
                }
                const groupChat = await client.getChatById(quotedMessage.id.remote);
                if (groupChat.isGroup) { // S'assurer que le message cit√© vient d'un groupe
                    await message.reply("D√©marrage de la diffusion.....");
                    await sendPrivateMessages(groupChat.participants);
                    await message.reply("Op√©ration de diffusion termin√©e ! ‚úÖ");
                } else {
                    await message.reply("Le message auquel vous r√©pondez ('diffusion2') ne provient pas d'un groupe.");
                }
            } catch (error) {
                console.error('Erreur lors de la diffusion (diffusion2):', error.message);
                await message.reply("‚ùå Une erreur est survenue lors de la tentative de diffusion via le message cit√©. Assurez-vous de r√©pondre √† un message de groupe valide.");
            }
        }
        if(message.body == ".save"){
            try {
                const quotedMessage = await message.getQuotedMessage();
                if (quotedMessage) {
                    savedMessage = quotedMessage; // Sauvegarde l'objet du message cit√©
                    await message.reply("Message sauvegard√© avec succ√®s pour un transfert futur ! ‚úÖ");
                    console.log(`Message sauvegard√©: ID ${quotedMessage.id._serialized}`);
                } else {
                    await message.reply("Veuillez r√©pondre au message que vous souhaitez sauvegarder avec la commande 'save'.");
                }
            } catch (error) {
                console.error('Erreur lors de la sauvegarde du message:', error.message);
                await message.reply("‚ùå Une erreur est survenue lors de la tentative de sauvegarde du message.");
            }
        }

        if (message.body.startsWith(".delais")) {
            try {
                const parts = message.body.trim().split(/\s+/);
                if (parts.length < 2) {
                    await message.reply("‚ùå Veuillez sp√©cifier un d√©lai en secondes. Exemple : `.delais 5`");
                    return;
                }
                const seconds = parseInt(parts[1], 10);
                if (isNaN(seconds) || seconds < 0) {
                    await message.reply("‚ùå Le d√©lai doit √™tre un nombre entier positif.");
                    return;
                }
                DELAIS = seconds * 1000; // conversion en millisecondes
                saveConfig(); // sauvegarde dans le fichier
                await message.reply(`‚è±Ô∏è D√©lai mis √† jour √† ${seconds} seconde(s).`);
                console.log(`DELAIS mis √† jour : ${DELAIS} ms`);
            } catch (error) {
                console.error('Erreur lors de la mise √† jour du d√©lai:', error.message);
                await message.reply("‚ùå Une erreur est survenue lors de la mise √† jour du d√©lai.");
            }
        }
        
        }
    
    else {
        const chat = await client.getChatById(message.id.remote);
        if (!chat.isGroup) {
            const str = message.body.toLowerCase();
            if (/bsr\s|bjr\s|bonsoir\s|bonjour\s|slt\s|salut\s/i.test(str)) {
                await message.react("üëã");
            }
            if (/ok\s|d'accord\s|merci\s|okay\s/i.test(str)) {
                await message.react("üëç");
            }

        }
    }
});




async function sendPrivateMessages(participants) {
    let successCount = 0;
    let failCount = 0;

    // V√©rifier si un message a √©t√© sauvegard√©
    if (!savedMessage) {
        console.error("Erreur: Aucun message sauvegard√© pour la diffusion.");
        // Il est important de g√©rer ce cas, m√™me si les checks sont faits en amont
        return;
    }


    for (const participant of participants) {
        try {
            const chat = await client.getChatById(participant.id._serialized);
            
            // On ne peut pas transf√©rer un message √† soi-m√™me (le bot)
            // ou √† un participant qui est l'ID du bot (tr√®s peu probable dans cette config, mais bonne pratique)
            if (participant.id._serialized === client.info.wid._serialized) {
                console.log(`Skipping self-transfer for ${participant.id._serialized}`);
                continue;
            }

            // --- TRANSFERT DU MESSAGE SAUVEGARD√â ---
            await savedMessage.forward(chat.id._serialized);

            console.log(`Message transf√©r√© √† ${participant.id._serialized} ‚úÖ`);
            successCount++;

            // Pause anti-spam
            await new Promise(resolve => setTimeout(resolve, DELAIS));
        } catch (error) {
            console.error(`√âchec du transfert pour ${participant.id._serialized} ‚ùå :`, error.message);
            failCount++;
        }
    }
    console.log(`OP√âRATION DE DIFFUSION TERMIN√âE ! Transferts r√©ussis : ${successCount}, √âchecs : ${failCount}`);
}


// Fonction pour sauvegarder la config
function saveConfig() {
    const data = {
        DELAIS,
        savedMessageId: savedMessage ? savedMessage.id._serialized : null
    };
    fs.writeFileSync(configPath, JSON.stringify(data, null, 2));
}
